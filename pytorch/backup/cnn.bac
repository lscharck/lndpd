#!/usr/bin/python3.8
import time
import torch
import numpy as np
from torch import nn
from torch import optim
import torch.nn.functional as F
from torch.utils.data import DataLoader, TensorDataset
from torchvision.transforms import ToTensor, Lambda, Compose

# check for cpu or gpu
device = 'cuda' if torch.cuda.is_available() else 'cpu'
print(f'Using {device} device')

bs = 64
epochs = 50

x = torch.from_numpy(np.expand_dims(np.load("image.npy"), 1))
y = torch.from_numpy(np.load("label.npy"))

x_train = x[:800]
y_train = y[:800]
x_valid = x[800:]
y_valid = y[800:]
print(x_train.size(), y_train.size())

train_ds = TensorDataset(x_train, y_train)
valid_ds = TensorDataset(x_valid, y_valid)

# Define CNN arch
class CNN(nn.Module):
    def __init__(self):
        super(CNN, self).__init__()
        self.conv = nn.Sequential(
            nn.Conv2d(1, 32, 3),
            nn.ReLU(),
            nn.AvgPool2d((2,2))
        )

        self.linear = nn.Sequential(
            nn.Flatten(),
            nn.Linear(32*13*13, 120),
            nn.ReLU(),
            nn.Linear(120, 84),
            nn.ReLU(),
            nn.Linear(84, 4),
        )

    def forward(self, x):
        x = self.conv(x)
        logits = self.linear(x)
        return logits

# Define loss function
loss_func = F.mse_loss

# Batch loss and updater/validater function
def loss_batch(model, loss_func, xb, yb, opt=None):
    loss = loss_func(model(xb), yb)

    if opt is not None:
        loss.backward()
        opt.step()
        opt.zero_grad()

    return loss.item(), len(xb)

# Define training function
def fit(epochs, model, loss_func, opt, train_dl, valid_dl):
    for epoch in range(epochs):
        start = time.time()
        model.train()
        for xb, yb in train_dl:
            loss_batch(model, loss_func, xb, yb, opt)

        end = time.time()

        model.eval()
        with torch.no_grad():
            mse, nums = zip(*[loss_batch(model, loss_func, xb, yb) for xb, yb in valid_dl])
        avg_mse = np.sum(mse) / np.sum(nums)

        print(f'Epoch: [{epoch+1}/{epochs}] ({end-start:.2g}s) -- avg_mse = {avg_mse}')

# Setup model
def get_model():
    model = CNN().to(device)
    return model, optim.Adam(model.parameters())

# Get and format data
def get_data(train_ds, valid_ds, bs):
    return (
    DataLoader(train_ds, batch_size=bs, shuffle=True),
    DataLoader(valid_ds, batch_size=bs * 2),
    )


### call and train model ###
train_dl, valid_dl = get_data(train_ds, valid_ds, bs)
model, opt = get_model()
fit(epochs, model, loss_func, opt, train_dl, valid_dl)
model.eval()
with torch.no_grad():
    pred = model(x_valid[:3])
print(np.round(pred[0]*28), y_valid[0]*28)
print(np.round(pred[1]*28), y_valid[1]*28)
print(np.round(pred[2]*28), y_valid[2]*28)
